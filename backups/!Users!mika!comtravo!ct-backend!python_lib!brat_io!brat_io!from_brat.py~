import json
import logging
from uuid import uuid4
from . ann2brat import _get_body_start, _get_subject_start_end, _get_from_start_end,\
    _get_cc_and_to_start_end
from . annotation import TextAnnotations, TextBoundAnnotationWithText, AttributeAnnotation,\
    EventAnnotation, OnelineCommentAnnotation, BinaryRelationAnnotation


logger = logging.getLogger(__name__)
logger.setLevel(logging.WARNING)


def _get_where(n_head, ann, s_start, s_end, from_start, from_end, to_start, cc_end):
    if ann.type == 'Attributes':
        # special handling 'Attributes case
        return 'body'
    min_start = min([s for s, e in ann.spans])
    max_end = max([e for s, e in ann.spans])
    if min_start >= n_head:
        return 'body'
    elif min_start >= s_start and max_end <= s_end:
        return 'subject'
    elif min_start >= from_start and max_end <= from_end:
        return 'from'
    elif min_start >= to_start and max_end <= cc_end:
        return 'cc_to'
    else:
        raise Exception("annotation at unknown position {}-{}: {}\n"
                        "subject inbetween {}-{}, head {}".format(
                            min_start, max_end, str(ann), s_start, s_end, n_head))


def brat2ann(file):
    """Parse a brat annotation for file on disk into internal json/dict format
    """
    n_head = _get_body_start(file)
    s_start, s_end = _get_subject_start_end(file)
    from_start, from_end = _get_from_start_end(file)
    to_start, cc_end = _get_cc_and_to_start_end(file)
    annotations = {'annotations': [],
                   'events': []}
    brat_ann = TextAnnotations(file, read_only=True)
    deferred_annotations = []
    id_map = {}

    def get_id(i):
        if i in id_map:
            return id_map[i]
        else:
            new_id = str(uuid4())
            id_map[i] = new_id
            return new_id

    for ann in brat_ann:
        if type(ann) is TextBoundAnnotationWithText:
            # The "standard" annotations placed on the text
            where = _get_where(n_head, ann, s_start, s_end, from_start, from_end, to_start, cc_end)
            if where == 'body':
                offset = n_head
            elif where == 'subject':
                offset = s_start
            elif where == 'from':
                offset = from_start
            elif where == 'to_cc':
                offset = to_start
            annotations['annotations'].append({
                'id': ann.id,
                'type': ann.type,
                'attributes': {},
                'spans': [{'start': start - offset, 'end': end - offset}
                          for start, end in ann.spans],
                'text': ann.text,
                'where': where})
        elif type(ann) is AttributeAnnotation:
            # ?!?
            deferred_annotations.append(ann)
        elif type(ann) is EventAnnotation:
            # The events
            annotations['events'].append({
                'id': ann.id,
                'type': ann.type,
                'attributes': {},
                'trigger': ann.trigger,
                'args': [{'name': name, 'target': target} for name, target in ann.args]
            })
        elif type(ann) is OnelineCommentAnnotation:
            # These are the "Notes" fields
            deferred_annotations.append(ann)
        elif type(ann) is BinaryRelationAnnotation:
            deferred_annotations.append(ann)
        else:
            raise Exception('{}: unknown/unhandled annotation type {}: {}'.format(
                file, type(ann), str(ann)))
    for ann in deferred_annotations:
        # Merge the annotations into the attribute field
        if type(ann) is AttributeAnnotation:
            for tag in [t for t in annotations['annotations'] if t['id'] in ann.reference_id()]:
                logger.warning('Attributes should go away - use notes instead and format as json!')
                tag['attributes'].update({ann.type.lower(): ann.value.lower()})
        elif type(ann) is OnelineCommentAnnotation:
            for tag in [t for t in annotations['annotations'] if t['id'] == ann.target]:
                try:
                    pay = json.loads(ann.get_text())
                    tag['attributes'].update(pay)
                except json.JSONDecodeError:
                    logger.warning("{}: failed to decode payload in {}: {}".format(
                        file, str(ann), ann.get_text()))
        elif type(ann) is BinaryRelationAnnotation:
            for tag in [t for t in annotations['annotations'] if t['id'] == ann.arg1]:
                if 'relates_to' not in tag:
                    tag['relates_to'] = []
                tag['relates_to'].append({'target': ann.arg2, 'type': ann.type})
            for tag in [t for t in annotations['annotations'] if t['id'] == ann.arg2]:
                if 'is_related_to' not in tag:
                    tag['is_related_to'] = []
                tag['is_related_to'].append({'source': ann.arg1, 'type': ann.type})

    for e in annotations['events']:
        # Merge event related tag data into event and delete tag
        t = next((a for a in annotations['annotations'] if a['id'] == e['trigger']), None)
        e['spans'] = t['spans']
        e['text'] = t['text']
        e['attributes'].update(t['attributes'])
        e.pop('trigger')
        annotations['annotations'].remove(t)
    # Replace all ids by uuids (to get something that can be generated
    # by us without knowledge of the other ids)
    for t in annotations['annotations']:
        t['id'] = get_id(t['id'])
        if 'relates_to' in t:
            for r in t['relates_to']:
                r['target'] = get_id(r['target'])
        if 'is_related_to' in t:
            for r in t['is_related_to']:
                r['source'] = get_id(r['source'])
    for e in annotations['events']:
        e['id'] = get_id(e['id'])
        for a in e['args']:
            a['target'] = get_id(a['target'])
    return annotations, brat_ann.get_document_text()
