import json
from uuid import uuid4


def strip(s):
    rs = s.rstrip()
    nr = len(s) - len(rs)
    ls = s.lstrip()
    nl = len(s) - len(ls)
    return s.strip(), nl, nr


def bratify_ann(msg, type, start, end, id=None, attributes={}, where='body'):
    text = msg[where][start:end].replace('\t', ' ')
    ranges = []
    texts = []
    text_lines = text.split('\n')
    pos = start
    for l in text_lines:
        ls, nl, nr = strip(l)
        if len(ls) > 0:
            ranges.append((pos+nl, pos+nl+len(ls)))
            texts.append(ls)
        pos += len(l) + 1
    return {
        'type': type,
        'id': id if id is not None else str(uuid4()),
        'attributes': attributes,
        'spans': [{'start': s, 'end': e} for s, e in ranges],
        'text': ' '.join(texts),
        'where': where
    }


def make_id(id, id_map):
    if id not in id_map:
        id_map['cnt'] += 1
        id_map[id] = id_map['cnt']
    return id_map[id]


def _write_tag(a, id_map, f, n_head=0, n_subject=0):
    id = 'T{}'.format(make_id(a['id'], id_map))
    if a['where'] == 'body':
        pass
    elif a['where'] == 'subject':
        n_head = n_subject
    else:
        raise Exception('unknown value {} for where field'.format(a['where']))

    if a['type'] == 'Attributes' and n_head > 0:
        a['spans'] = [{'start': 0, 'end': 0}]
        n_head -= 10

    f.write('{id}\t{type} {range}\t{text}\n'.format(
        id=id,
        type=a['type'],
        range=';'.join(['{} {}'.format(s['start'] + n_head, s['end'] + n_head)
                        for s in a['spans']]),
        text=a['text']))
    if len(a['attributes']) > 0:
        id_map['a_cnt'] += 1
        f.write('#{a_count}\tAnnotatorNotes {target}\t{text}\n'.format(
            a_count=id_map['a_cnt'],
            target=id,
            text=json.dumps(a['attributes'])))


def _get_subject_start_end(file_stem):
    """Find position in brat txt file where subject starts"""
    txt = open(file_stem + '.txt', 'r').read()
    n_head = 0
    for line in txt.split('\n'):
        if line.startswith('SUBJECT: '):
            return n_head + len('SUBJECT: '), n_head + len(line)
        else:
            n_head += len(line) + 1
        if 'End of header' in line:
            break
    raise Exception('no subject line found')


def _get_from_start_end(file_stem):
    """Find position in brat txt file where from starts"""
    txt = open(file_stem + '.txt', 'r').read()
    n_head = 0
    for line in txt.split('\n'):
        if line.startswith('FROM: '):
            return n_head + len('FROM: '), n_head + len(line)
        else:
            n_head += len(line) + 1
        if 'End of header' in line:
            break
    raise Exception('no from line found')


def _get_cc_and_to_start_end(file_stem):
    """Find position in brat txt file where to starts and cc ends"""
    txt = open(file_stem + '.txt', 'r').read()
    n_head = 0
    end_ = _get_body_start(file_stem) - 1
    for line in txt.split('\n'):
        if line.startswith('TO: '):
            return n_head + len('TO: '), end_
        else:
            n_head += len(line) + 1
        if 'End of header' in line:
            break
    raise Exception('no from line found')


def _get_body_start(file_stem):
    """Find position in brat txt file where actual message body starts"""
    txt = open(file_stem + '.txt', 'r').read()
    n_head = 0
    for line in txt.split('\n'):
        n_head += len(line) + 1
        if 'End of header' in line:
            break
    return n_head


def ann2brat(ann, file_stem):
    """Convert our internal dict/json based annotation format in ann for
    message msg to the brat standoff format
    (cf. http://brat.nlplab.org/standoff.html)

    ann: the annotations json
    f: file handle to write to
    n_head: number of bytes that are header data in the message text
    """
    n_head = _get_body_start(file_stem)
    n_subject, _ = _get_subject_start_end(file_stem)
    with open(file_stem + '.ann', 'w', encoding='utf-8') as f:
        id_map = {'cnt': 0, 'a_cnt': 0}
        for a in ann['tags']:
            _write_tag(a, id_map, f, n_head, n_subject)
        for e in ann['events']:
            _write_tag(e, id_map, f, n_head, n_subject)
            id = 'E{}'.format(make_id(str(uuid4()), id_map))
            f.write('{id}\t{type}:{trigger} {args}\n'.format(
                id=id,
                type=e['type'],
                trigger='T{}'.format(make_id(e['id'], id_map)),
                args=' '.join(['{}:T{}'.format(
                    a['name'], make_id(a['target'], id_map)) for a in e['args']])))
