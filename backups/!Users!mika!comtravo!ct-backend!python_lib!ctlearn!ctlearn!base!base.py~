import pickle
from abc import ABCMeta
from uuid import uuid4
from copy import deepcopy
from inspect import signature


class SerializableMixin(object):
    def save(self, file):
        pickle.dump(self, file, fix_imports=False)

    @classmethod
    def load(cls, file):
        return pickle.load(file, fix_imports=False)


def _fit_and_score(estimator, X, y, scorer, train, test,
                   parameters, fit_params):
    '''based on https://github.com/mrocklin/dasklearn/blob/master/dasklearn/grid_search.py'''
    if parameters is not None:
        estimator = estimator.set_params(estimator, **parameters)

    X_train = X[train]
    y_train = y[train]
    X_test = X[test]
    y_test = y[test]

    if y_train is None:
        estimator = estimator.fit(X_train, **fit_params)
    else:
        estimator = estimator.fit(X_train, y_train, **fit_params)

    test_score = estimator.score(X_test, y_test)

    ret = [test_score, X_test.shape[0], parameters]
    return ret


class ProcessorBase(object, metaclass=ABCMeta):
    def __init__(self, id=None, input_keys=None, output_key=None, input_targets=None):
        self.id = str(uuid4())
        self.input_keys = input_keys
        self.output_key = output_key
        self.input_targets = input_targets

    def clone(self):
        new_params = deepcopy(self.get_params(include_base=True))
        new_obj = self.__class__(**new_params)
        return new_obj

    def get_params(self, include_base=False):
        """Based on sklearn BaseEstimator

        Get parameters for this estimator.
        """
        out = dict()
        for key in self._get_param_names():
            if include_base or key not in ['id', 'input_keys', 'output_key', 'input_targets']:
                value = getattr(self, key, None)
                out[key] = value
        return out

    def set_params(self, **params):
        if params:
            valid_params = self._get_param_names()
            for parameter, value in params.items():
                if parameter not in valid_params:
                    raise ValueError('invalid parameter {} for {}'.format(
                        parameter, self.__class__.__name__))
                setattr(self, parameter, value)
        return self

    @classmethod
    def _get_param_names(cls):
        """Copied from sklearn BaseEstimator

        Get parameter names for the estimator"""
        init = getattr(cls.__init__, 'deprecated_original', cls.__init__)
        if init is object.__init__:
            return []

        init_signature = signature(init)
        parameters = [p for p in init_signature.parameters.values()
                      if p.name != 'self' and p.kind != p.VAR_KEYWORD]
        for p in parameters:
            if p.kind == p.VAR_POSITIONAL:
                raise RuntimeError("processors must "
                                   "specify their parameters in the signature"
                                   " of their __init__ (no varargs)."
                                   " %s with constructor %s doesn't "
                                   " follow this convention."
                                   % (cls, init_signature))
        # Extract and sort argument names excluding 'self'
        return sorted([p.name for p in parameters])
