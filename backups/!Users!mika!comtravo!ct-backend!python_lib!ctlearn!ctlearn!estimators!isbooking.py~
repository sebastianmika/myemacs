from ..base_model import BaseModel
from . type_model_helpers import ann2txt, best_of_folds
import os
import numpy as np
from sklearn.pipeline import Pipeline, FeatureUnion
from sklearn.model_selection import GridSearchCV, StratifiedKFold
from sklearn.metrics import roc_curve, auc
from scipy import interp
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.ensemble import RandomForestClassifier
from . vocabulary_signal_words import get_signal_words


class TypeModel(BaseModel):
    def __init__(self):
        self.model = None
        self.model_name = "type_model"
        self.model_path = os.path.dirname(__file__) + "/models/" + self.model_name + ".pkl"

    def fit(self, X, y, lemmatize=False):
        self.model = {}
        for lang in ["de", "en"]:
            X_ = X[lang]
            y_ = y[lang]
            vocab = get_signal_words(lang, lemmatize)

            rf_clf = Pipeline([
                ('union', FeatureUnion([
                    ('tfidf', TfidfVectorizer(strip_accents='unicode',
                                              use_idf=1, ngram_range=(1, 1))),
                    ('bow', CountVectorizer(analyzer='word', vocabulary=vocab))
                ])),
                ('clf', RandomForestClassifier(n_jobs=-1, n_estimators=100, min_samples_leaf=1))])

            if self.params:
                rf_clf._set_params('steps', **self.params[lang])
            rf_clf.fit(X_, y_)
            self.model[lang] = {"clf": rf_clf}

    @classmethod
    def prepare_data(cls, data):
        X_dict, y_dict = {}, {}
        for lang in ["de", "en"]:
            messages = []
            for elem in data:
                msg = {'language': elem['ann']['language'],
                       'label': elem['ann']['label'],
                       'text': ann2txt(elem['ann']['annotations'])}
                messages.append(msg)

            X = np.array([message['text'] for message in messages if message['language'] == lang])

            # simplify labels, only booking and no booking
            y = np.array([1 if message['label'] == 'booking' else -1
                          for message in messages if message['language'] == lang])
            X_dict[lang] = X
            y_dict[lang] = y
        return X_dict, y_dict

    def apply(self, sample, lang=None):
        if self.model:
            if not lang:
                lang = sample['language']
                sample = [ann2txt(sample['annotations'])]
            if lang in self.model.keys():
                p = self.model[lang]["clf"].predict_proba(sample)
                return p[0][1]
            else:
                return 0.0
        else:
            raise TypeError('No model loaded!')

    def metric(self, y_true, y_pred):
        fpr, tpr, ths = roc_curve(y_true, y_pred)
        return auc(fpr, tpr)

    def score(self, X, y):
        '''
        Validates the model.
        Input:
            - data: list, same length as labels
            - labels: list or array, same length as data
            - metric: callable taking labels and
                      predictions of the model as input
        '''
        if self.model:
            preds = []
            labels = []
            for lang in ["de", "en"]:
                for s, l in zip(X[lang], y[lang]):
                    p = self.apply([s], lang)
                    preds.append(p)
                    labels.append(l)
            return self.metric(np.array(labels), np.array(preds))
        else:
            raise ValueError

    def tune(self, X, y, lemmatize=False):
        self.params = {}
        for lang in ["de", "en"]:
            X_ = X[lang]
            y_ = y[lang]
            vocab = get_signal_words(lang, lemmatize)

            n_outer_folds = 3
            n_inner_folds = 5
            skf_outer = StratifiedKFold(n_splits=n_outer_folds)
            skf_outer_splits = skf_outer.split(X_, y_)
            mean_tpr = 0.0
            mean_fpr = np.linspace(0, 1, 100)

            # SMA: Does mixing tfidf and bow as features make sense? shouldn't that be either/or?
            params = {
                'union__tfidf__ngram_range': [(1, 1), (1, 2)],
                'clf__min_samples_leaf': [1, 5, 10],
                'clf__n_estimators': [1000]
            }
            best_params = []
            for i, (tr_idx, te_idx) in enumerate(skf_outer_splits):
                rf_clf = Pipeline([
                    ('union', FeatureUnion([
                        ('tfidf', TfidfVectorizer(strip_accents='unicode', use_idf=1)),
                        ('bow', CountVectorizer(analyzer='word', vocabulary=vocab))
                    ])),
                    ('clf', RandomForestClassifier(n_jobs=-1))])
                # if the estimator is a classifier, StratifiedKFold is used.
                cv = GridSearchCV(rf_clf, params, cv=n_inner_folds, n_jobs=1, verbose=0)
                cv.fit(X_[tr_idx], y_[tr_idx])
                proba = cv.best_estimator_.predict_proba(X_[te_idx])
                best_params.append(cv.best_params_)
                fpr, tpr, ths = roc_curve(y_[te_idx], proba[:, 1])
                mean_tpr += interp(mean_fpr, fpr, tpr)
                mean_tpr[0] = 0.0
                # roc_auc = auc(fpr, tpr)
                # print("...fold {} roc auc {:.2f}".format(i, roc_auc))

            mean_tpr /= n_outer_folds
            mean_roc_auc = auc(mean_fpr, mean_tpr)

            print("Finished: avg roc auc {:.2f}".format(mean_roc_auc))
            selected_params = best_of_folds(best_params)
            print(selected_params)
            rf_clf._set_params('steps', **selected_params)
            rf_clf.fit(X_, y_)
            self.params[lang] = selected_params
