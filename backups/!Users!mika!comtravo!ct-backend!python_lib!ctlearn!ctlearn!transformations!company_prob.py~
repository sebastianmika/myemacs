from .. base import Transformer
import logging
from es_client import query_elasticsearch


logger = logging.getLogger(__name__)


class CompanyProbTransformer(Transformer):
    def __init__(self):
        super(CompanyProbTransformer, self).__init__(input_keys=['crm_company', 'crm_person'],
                                                     output_key='p_company')

    def prob_companies(self, crm_company, crm_person):
        # Add list of companies with prob to result
        if crm_company:
            companies = [{
                'id': cid,
                'probability': crm_company[cid]['probability']} for
                         cid in sorted(crm_company.keys())]
        else:
            companies = {}
        # Now, recalculate the probs and adjust
        tids = [uid for uid, u in crm_person.items() if
                'body' in u['msg_roles'] or 'subject' in u['msg_roles'] or
                'cc' in u['msg_roles'] or 'to' in u['msg_roles']]
        if not tids:
            return companies
        query = {
            "query": {
                "bool": {
                    "filter": [
                        {"terms": {"booking_items.traveler_id": tids}},
                        {"range": {"meta_data.created_at": {"gte": "now-90d"}}},
                        {"term": {"status": "processed"}}
                    ]
                }
            },
            "size": 0,
            "aggs": {
                "companies": {
                    "terms": {
                        "field": "company_id",
                        "size": 0
                    }
                }
            }
        }
        res_es = query_elasticsearch(query, index='bookings')
        if res_es['status'] != 200:
            logger.error("failed to query bi for updating company probs")
            return companies
        companies = res_es['result']
        if companies['hits']['total'] == 0:
            # nothing found - weird, but lets just ignore that
            return companies
        c_prob = {k['key']: k['doc_count'] for k in
                  companies['aggregations']['companies']['buckets']}
        if set(c_prob.keys()).difference(crm_company.keys()):
            logger.error('found more companies when searching by users than '
                         'these users are associated with?!')
            return companies
        total = max(sum(c_prob.values()), 1)
        c_prob = {k: v/total for k, v in c_prob.items()}
        for cid, c in crm_company.items():
            if cid in c_prob:
                c['probability'] = (c['probability'] + c_prob[cid])/2.0

        # Add list of company with prob to result
        if crm_company:
            companies = [{
                'id': cid,
                'probability': crm_company[cid]['probability']} for
                         cid in sorted(crm_company.keys())]
        return companies

    def tag(self, crm_company, crm_person):
        # Adjust company probabilites by getting counts of bookings
        # where each mentioned user was a traveler (and mentioned not
        # only as the booker)
        if not 'crm_company':
            return {}
        # self.prob_persons(result)
        return self.prob_companies(crm_company, crm_person)

    def transform(self, *args):
        res = [None] * len(args[0])
        for idx, (crm_company, crm_person,) in enumerate(zip(*args)):
            res[idx] = self.tag(crm_company, crm_person)
        return res
