import logging
from . base_tagger import BaseTagger, TagStatus
from es_client import query_elasticsearch


logger = logging.getLogger(__name__)


class CRMCompanyTagger(BaseTagger):
    def tag(self, msg, result):
        """Given a message with 'from', 'to' and 'cc', query bi for all
        documents where either of these email adresses is given for a
        traveler (excluding those emails that contain "comtravo.").

        Adds a field 'crm' to result with sub-fields 'companies' and 'users'.

        'companies' are the unique companies associated with these travelers.
        Each company is associated with a likelihood of being the correct
        company by weighting it by the number of emails in the message
        matched that are associated with that company.

        'users' is a dictionary of {email: {'crm_id': x, 'fields':
        ['to', 'cc', 'from']} to allow tagging the people involved in the
        communication directly. Also, not all travelers have a company
        associated and would be lost otherwise.

        :returns: TagStatus

        """

        # Get all companies the sender of the message ever booked for
        query_bookings = {
            "query": {
                "bool": {
                    "filter": [
                        {"match_phrase": {"booker.email": "{}".format(msg['from']['email'])}},
                        {"range": {"meta_data.created_at": {"gte": "now-90d"}}},
                        {"term": {"status": "processed"}}
                    ]
                }
            },
            "size": 0,
            "aggs": {
                "companies": {
                    "terms": {
                        "field": "company_id",
                        "size": 0
                    }
                }
            }
        }
        emails = {e: 1 for e in [msg['from']['email']] +
                  [c['email'] for c in msg['cc'] if 'comtravo.' not in c['email']] +
                  [t['email'] for t in msg['to'] if 'comtravo.' not in t['email']]}.keys()
        query_travelers = {
            'query': {
                'bool': {
                    'should': [
                        {
                            'match_phrase': {'email': e}
                        }
                        for e in emails],
                    'minimum_should_match': 1
                }
            },
            'size': 0,
            'aggs': {  # ...but just aggregations over different company_ids
                'companies': {
                    'terms': {  # Get all matching company_id's
                        'field': 'company'
                    }
                }
            }
        }
        result['crm'] = {'companies': {}, 'users': {}}
        # First try on bookings
        penalty = 1.0
        es_res = query_elasticsearch(query_bookings, index='bookings')
        if es_res['status'] != 200:
            return TagStatus.server_error
        if es_res['result']['hits']['total'] == 0:
            logger.warning('no bookings found for ticket {}, retrying against travelers'.format(
                msg['zendesk_ticket_id']))
            penalty = 0.75
            es_res = query_elasticsearch(query_travelers, index='travelers')
        if es_res['status'] != 200:
            return TagStatus.server_error
        if es_res['result']['hits']['total'] == 0:
            return TagStatus.success
        companies = es_res['result']
        # Elasticserchs's hits.total is even for simple example not
        # identical to the sum of doc_counts in the aggregations (it is
        # one off). Whilst what is in principle possible and documented,
        # it still seems to be a bug somehow (as contrary to the
        # documentation in that simple example the
        # doc_count_error_upper_bound is zero).  So I sum up the
        # doc_counts to get a company likelihood which is determined by
        # the number of times a company matched any of the mentioned
        # emails in the message
        total_doc_count = sum(
            [k['doc_count']
             for k in companies['aggregations']['companies']['buckets']])
        result['crm']['companies'] = {
            k['key']: {
                'probability': k['doc_count']/total_doc_count * penalty}
            for k in companies['aggregations']['companies']['buckets']}
        return TagStatus.success
