from .. base import Transformer
from collections import namedtuple
from spacy.orth import word_shape
import logging
from .. utils import _get_longest_match

logger = logging.getLogger(__name__)

MergeItem = namedtuple('MergeItem', ['start', 'length', 'payload'])


class MergeTransformer(Transformer):
    def __init__(self):
        super(MergeTransformer, self).__init__(
            input_keys=['msg_trc', 'spacy', 'person', 'time',
                        'iata', 'fn', 'location', 'airline', 'category_or_class',
                        'luggage'],
            output_key='annotation')

    def tag(self, msg, spacy, *annotations):
        """
        {'where': 'subject|body',
         'start': 1,
         'length': 10,
         'text': 'bla',
         'after': ' ',
         'id': 'uuid'|None,
         'attributes': {}|None,
         'rner': 'I/B-Person'
         'pos': '',
         'ner': 'O|I-Person|B-Person|...',
         'shape': '',
        'tag': '',
        'sentence': int}
        """
        if not spacy:
            # If spacy failed, there is nothing we can merge
            return None
        # make all annotations into a list of dicts
        annotations = sum([a if type(a) is list else [a] for a in annotations if a], [])
        annotations = _get_longest_match(annotations)
        ret = []
        for where in ['subject', 'body']:
            T = sorted([MergeItem(start=t['start'],
                                  length=t['length'],
                                  payload=dict(**t, sentence=i_s))
                        for i_s, s in enumerate(spacy[where]) for t in s['tokens']],
                       key=lambda x: x.start)
            A = sorted([MergeItem(start=b['start'],
                                  length=b['length'],
                                  payload=b)
                        for a in annotations if a['where'] == where
                        for b in MergeTransformer._ann2tok(a)],
                       key=lambda x: x.start)
            C = MergeTransformer._merge(T, A)
            # ToDo: This seems like a complicated way to express msg[where]
            txt = msg['analyzed'][where]['text'][
                msg['analyzed'][where]['start']:msg['analyzed'][where]['end']]
            ret += MergeTransformer._unify_merge(txt, where, C)
        return ret

    @classmethod
    def _merge(cls, A, B):
        # A and B are lists of MergeItems a[i] and b[i], such that
        #
        # - a[i].start < a[i+1].start
        # - b[i].start < b[i+1].start
        # - a[0].start <= b[0].start
        # - a[-1].start + a[-1].length >= b[-1].start + b[-1].length
        # - forall b, exists a such that a.start <= b.start <= a.start + a.length
        #
        # Return a new list of MergeItems sorted by start and with payload
        # either an original payload from A or B or a tuple of a payload
        # from A and B
        C = []
        while True:
            if len(B) == 0:
                # nothing to do
                C += A
                return C
            elif len(A) == 0:
                raise ValueError("trying to merge non emtpy sequence B in empty sequence A?!?")
            # there is at least on element in A and B, both are sorted by 'start'
            elif A[0].start > B[0].start:
                logger.warning('Sequence A starts after sequence B, skipping one in B')
                B = B[1:]
            elif A[-1].start + A[-1].length < B[-1].start + B[-1].length:
                raise ValueError('A sequence must not be shorter than B sequence')
            # if the first element in A ends before the first element in B starts recurse
            elif A[0].start + A[0].length <= B[0].start:
                C.append(A[0])
                A = A[1:]
            # if first element in A starts before first element in B,
            # split first element in A such that the second part starts
            # exactly at the first element of B
            elif A[0].start < B[0].start:
                # Split A[0] into two tokens, one before B[0] and one starting at B[0].start
                a0 = MergeItem(start=A[0].start, length=B[0].start - A[0].start,
                               payload=A[0].payload)
                a1 = MergeItem(start=B[0].start, length=A[0].start + A[0].length - B[0].start,
                               payload=A[0].payload)
                C.append(a0)
                A = [a1] + A[1:]
            # from here A[0].start == B[0].start as A[0].start >
            # B[0].start is not possible
            elif A[0].length < B[0].length:
                # A[0] shorter than B[0]: split B[0]
                b0 = MergeItem(start=B[0].start, length=A[0].length, payload=B[0].payload)
                # there must be a follow up token in A; take b1 start to
                # be at the next token in the A sequence (that should be
                # the separator character from the A sequence)
                b1 = MergeItem(start=A[1].start, length=B[0].start + B[0].length - A[1].start,
                               payload=B[0].payload)
                if b1.length == 0:
                    # This can happen if the B token (i.e. the
                    # annotation) includes only one additional char
                    # which was the one at which spacy split the text.
                    B = [b0] + B[1:]
                else:
                    B = [b0, b1] + B[1:]
            elif A[0].length > B[0].length:
                # B[0] shorter than A[0]: split A[0]
                a0 = MergeItem(start=A[0].start, length=B[0].length, payload=A[0].payload)
                a1 = MergeItem(start=B[0].start + B[0].length, length=A[0].length - B[0].length,
                               payload=A[0].payload)
                A = [a0, a1] + A[1:]
            else:
                # that what all the recursion was for: now the first
                # elements of A and B have the same size and we can just
                # merge them together
                assert A[0].start == B[0].start and A[0].length == B[0].length
                a = MergeItem(start=A[0].start, length=A[0].length,
                              payload=(A[0].payload, B[0].payload))
                C.append(a)
                A = A[1:]
                B = B[1:]

    @classmethod
    def _ann2tok(cls, a):
        return [dict(**a, start=s['start'], length=s['end'] - s['start'])
                for s in a['spans']]

    @classmethod
    def _unify_merge(cls, txt, where, C):
        res = []
        for c_idx, c in enumerate(C):
            if type(c.payload) is tuple:
                spacy_payload = c.payload[0]
                ann_payload = c.payload[1]
            else:
                spacy_payload = c.payload
                ann_payload = None

            if c_idx < len(C) - 1:
                next_C = C[c_idx+1]
                after = txt[c.start+c.length:next_C.start]
            else:
                after = txt[c.start+c.length:]

            if ann_payload:
                ann_id = ann_payload['id']
                ann_attributes = ann_payload['attributes']
                split_status = 'B' if ann_payload['start'] == c.start else 'I'
                ann_ner = '{}-{}'.format(split_status, ann_payload['type'])
            else:
                ann_ner = 'O-'
                ann_id = None
                ann_attributes = None

            token_txt = txt[c.start:c.start+c.length]
            token_shape = word_shape(token_txt)

            split_status = spacy_payload['ner_iob'] if spacy_payload['start'] == c.start else 'I'
            spacy_ner = ('{}-{}'.format(split_status, spacy_payload['ner'])
                         if spacy_payload['ner'] else 'O-')
            split_status = 'B' if spacy_payload['start'] == c.start else 'I'
            spacy_pos = '{}-{}'.format(split_status, spacy_payload['pos'])
            spacy_tag = '{}-{}'.format(split_status, spacy_payload['tag'])

            t = {
                'start': c.start,
                'length': c.length,
                'where': where,
                'text': token_txt,
                'after': after,
                'ner': spacy_ner,
                'shape': token_shape,
                'tag': spacy_tag,
                'pos': spacy_pos,
                'sentence': spacy_payload['sentence'],
                'rner': ann_ner
            }
            if ann_id:
                t['id'] = ann_id
            if ann_attributes:
                t['attributes'] = ann_attributes
            res.append(t)
        return res

    def transform(self, *args):
        res = [None] * len(args[0])
        for idx, (msg, spacy, *annotations, ) in enumerate(zip(*args)):
            print(annotations)
            res[idx] = self.tag(msg, spacy, annotations)
        return res

    @classmethod
    def print_merge(self, M):
        print("{where:7s}:{sentence:>2s} {start:>4s} {length:>4s} {pos:<10s} "
              "{tag:9s} {ner:12s} {rner:14s} {shape:8s} {text:10s} {label:10s}".format(
                  where='where', sentence='s', start='strt', length='len',
                  pos='pos', tag='tag', ner='ner', rner='rner', shape='shape',
                  text='text', label='label'))
        print("-" * 80)
        for m in M:
            print("{where:7s}:{sentence:2d} {start:4d} {length:4d} {pos:10s} "
                  "{tag:9s} {ner:12s} {rner:14s} {shape:8s} {text:10.10s} {label:10s}".format(**m))
