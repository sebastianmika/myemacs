from .. base import Transformer
import logging
from . base_tagger import BaseTagger, TagStatus
from es_client import query_elasticsearch


logger = logging.getLogger(__name__)


class CompanyProbTransformer(Transformer):
    def __init__(self):
        super(CompanyProbTransformer, self).__init__(input_keys=['crm_company', 'crm_person'],
                                                     output_key='company')

    def prob_persons(self, result):
        # Make list of users with probability by collecting scores per
        # user to be in a role.
        #
        # For bookers each user gets the relative scores he acquired
        # (so that all user probs for booker sum to one)
        #
        # For travelers, traveler prob should be equal for all
        # travelers with the same score, but they need not sum up to
        # one. Rather all unique scores get a prob that should add to
        # one, and then each traveler gets the prob assigned to its
        # score rank

        r_users = result['crm']['users']
        # Scores
        tot_booker = 0
        scores = {pid: {'booker': 0,
                        'traveler': 0} for pid in r_users.keys()}
        for uid, u in r_users.items():
            scores[uid]['booker'] += u['msg_roles']['from']
            tot_booker += u['msg_roles']['from']
            scores[uid]['traveler'] += 1.1 * u['msg_roles']['subject']
            if 'from' not in u['msg_roles']:
                # only count 'to' and 'cc' if not also from
                scores[uid]['traveler'] += u['msg_roles']['to']
                scores[uid]['traveler'] += u['msg_roles']['cc']
                scores[uid]['traveler'] += u['msg_roles']['body']
            else:
                scores[uid]['traveler'] += u['msg_roles']['body']

        # Get all different traveler score ranks
        tr_ranks = set([s['traveler'] for s in scores.values()])
        tot_booker = max(tot_booker, 1)
        max_tr_ranks = max(max(tr_ranks, default=1), 1)
        tr_ranks = {t: t/max_tr_ranks for t in tr_ranks}
        # Compile list of users
        # (sorted only here to make tests happy about list ordering)
        users = [{'id': pid, 'roles': []} for pid in sorted(r_users.keys())]
        for u in users:
            if scores[u['id']]['booker']:
                u['roles'].append({'role': 'booker',
                                   'probability': scores[u['id']]['booker']/tot_booker})
            if scores[u['id']]['traveler']:
                u['roles'].append(
                    {'role': 'traveler',
                     'probability': tr_ranks[scores[u['id']]['traveler']]})
        if users:
            result['users'] = users

    def prob_companies(self, crm_company, crm_person):
        # Add list of companies with prob to result
        if crm_company:
            companies = [{
                'id': cid,
                'probability': crm_company[cid]['probability']} for
                         cid in sorted(crm_company.keys())]
        # Now, recalculate the probs and adjust
        tids = [uid for uid, u in crm_person.items() if
                'body' in u['msg_roles'] or 'subject' in u['msg_roles'] or
                'cc' in u['msg_roles'] or 'to' in u['msg_roles']]
        if not tids:
            return companies
        query = {
            "query": {
                "bool": {
                    "filter": [
                        {"terms": {"booking_items.traveler_id": tids}},
                        {"range": {"meta_data.created_at": {"gte": "now-90d"}}},
                        {"term": {"status": "processed"}}
                    ]
                }
            },
            "size": 0,
            "aggs": {
                "companies": {
                    "terms": {
                        "field": "company_id",
                        "size": 0
                    }
                }
            }
        }
        res_es = query_elasticsearch(query, index='bookings')
        if res_es['status'] != 200:
            logger.error("failed to query bi for updating company probs")
            return companies
        companies = res_es['result']
        if companies['hits']['total'] == 0:
            # nothing found - weird, but lets just ignore that
            return companies
        c_prob = {k['key']: k['doc_count'] for k in
                  companies['aggregations']['companies']['buckets']}
        if set(c_prob.keys()).difference(crm_company.keys()):
            logger.error('found more companies when searching by users than '
                         'these users are associated with?!')
            return companies
        total = max(sum(c_prob.values()), 1)
        c_prob = {k: v/total for k, v in c_prob.items()}
        for cid, c in crm_company.items():
            if cid in c_prob:
                c['probability'] = (c['probability'] + c_prob[cid])/2.0

        # Add list of company with prob to result
        if crm_company:
            companies = [{
                'id': cid,
                'probability': crm_company[cid]['probability']} for
                         cid in sorted(crm_company.keys())]
        return companies

    def tag(self, crm_company, crm_person):
        # Adjust company probabilites by getting counts of bookings
        # where each mentioned user was a traveler (and mentioned not
        # only as the booker)
        if not 'crm_company':
            return {}
        # self.prob_persons(result)
        return self.prob_companies(crm_company, crm_person)

    def transform(self, *args):
        res = [None] * len(args[0])
        for idx, (crm_company, crm_person,) in enumerate(zip(*args)):
            res[idx] = self.tag(crm_company)
        return res
