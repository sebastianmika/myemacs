import logging
from . base_tagger import BaseTagger, TagStatus
from . helpers import _query_elasticsearch


logger = logging.getLogger(__name__)


class CRMCompanyTagger(BaseTagger):
    def tag(self, msg, result):
        """Given a message with 'from', 'to' and 'cc', query bi for all
        documents where either of these email adresses is given for a
        traveler (excluding those emails that contain "comtravo.").

        Adds a field 'crm' to result with sub-fields 'companies' and 'users'.

        'companies' are the unique companies associated with these travelers.
        Each company is associated with a likelihood of being the correct
        company by weighting it by the number of emails in the message
        matched that are associated with that company.

        'users' is a dictionary of {email: {'crm_id': x, 'fields':
        ['to', 'cc', 'from']} to allow tagging the people involved in the
        communication directly. Also, not all travelers have a company
        associated and would be lost otherwise.

        :returns: TagStatus

        """

        # Get unique email adresses in from, to and cc which are not related to comtravo
        emails = {e: 1 for e in [msg['from']['email']] +
                  [c['email'] for c in msg['cc'] if 'comtravo.' not in c['email']] +
                  [t['email'] for t in msg['to'] if 'comtravo.' not in t['email']]}.keys()
        query = {
            'query': {
                'bool': {
                    'should': [
                        {
                            'match_phrase': {'email': e}
                        }
                        for e in emails],
                    'minimum_should_match': 1
                }
            },
            'size': 0,
            'aggs': {  # ...but just aggregations over different company_ids
                'unique_companies': {
                    'terms': {  # Get all matching company_id's
                        'field': 'company'
                    }
                }
            }
        }
        es_res = _query_elasticsearch(query)
        logger.debug('get_companies: query emails = {}'.format(emails))
        logger.debug('get_companies: query term = {}'.format(query))
        logger.debug('get_companies: result = {}'.format(es_res))
        result['crm'] = {'companies': {}, 'users': {}}
        if es_res['status'] != 200:
            if es_res['status'] == 900:
                return TagStatus.server_error
            else:
                return TagStatus.client_error
        companies = es_res['result']
        if companies['hits']['total'] == 0:
            return TagStatus.success
        c_missing = companies['aggregations']['unique_companies']['sum_other_doc_count']
        if c_missing > 0:
            logger.warning('not all potential companies returned in query ({} missing)'.format(
                c_missing))
        # Elasticserchs's hits.total is even for simple example not
        # identical to the sum of doc_counts in the aggregations (it is
        # one off). Whilst what is in principle possible and documented,
        # it still seems to be a bug somehow (as contrary to the
        # documentation in that simple example the
        # doc_count_error_upper_bound is zero).  So I sum up the
        # doc_counts to get a company likelihood which is determined by
        # the number of times a company matched any of the mentioned
        # emails in the message
        total_doc_count = 0
        for k in companies['aggregations']['unique_companies']['buckets']:
            total_doc_count += k['doc_count']
        result['crm']['companies'] = {
            k['key']: {
                'likelihood': k['doc_count']/float(total_doc_count),
                'users': {}}
            for k in companies['aggregations']['unique_companies']['buckets']}
        return TagStatus.success
