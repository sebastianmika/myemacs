import regex as re
from datetime import datetime
from dateutil import parser
from dateutil.relativedelta import relativedelta
import pytz
from brat_io import bratify_ann
from . helpers import _query_duckling, _get_longest_match, tag_wrapper, TagStatus
from . set_cover import set_cover


def _process_response(msg, ans, where):
    if ans is None:
        return []
    matches = []
    # Run set cover on all returned results - try to get the minimal
    # number of annotations from duckling that cover all text indices
    # that any one indication includes; the set cover approximation
    # should keep the longer of two annotations is it is a super set
    # of a shorter one.
    for d in set_cover(ans['result']):
        if d['dim'] != 'time':
            # We only deal with time (point or intervals) here
            continue
        # Duckling is rather optimistic about determining time phrases
        # esp. in strings like "AB3C", it will interpret 3 as 3h,
        # etc. Instead of fixing this in duckling I rather fix that
        # here by looking at the context
        if re.match('[+-]?\d+', d['body']):
            # a sequence of only numbers was matched - ignore that if...
            if d['end'] - d['start'] < 4:
                # ... it has less than 4 digits
                continue
        # Any times that are in the past
        ref_date = datetime.fromtimestamp(msg['date']/1e3, tz=pytz.UTC)
        if d['value']['type'] == 'value':
            try:
                parsed_date = parser.parse(d['value']['value'])
            except:
                # if parsing the date fails we ignore it
                continue
            if (parsed_date < ref_date or parsed_date > ref_date + relativedelta(years=2)):
                continue
        # if d['end'] - d['start'] < 4:
        #    # Skip over extremely short matches
        #    continue
        if d['value']['type'] == 'value':
            tt = 'TimePoint'
        elif d['value']['type'] == 'interval':
            tt = 'TimeRange'
        else:
            raise Exception('unknown dim/type {} in duckling prediction'.format(d['dim']))
        if 'values' in d['value']:
            d['value'].pop('values')
        m = bratify_ann(msg, tt, d['start'], d['end'],
                        attributes=d['value'], where=where)
        matches.append(m)
    # no need to merge double matches - set_cover should already have
    # removed them...
    return _get_longest_match(matches)


@tag_wrapper("tag_time")
def tag_time(msg, result):
    query = {
        'text': msg['body'],
        'lang': result['language'],
        'date': msg['date']
    }
    ans = _query_duckling(query)
    if ans['status'] == 900 or ans['status'] == 500:
        return TagStatus.server_error
    elif ans['status'] != 200:
        return TagStatus.client_error
    matches = _process_response(msg, ans, where='body')
    query = {
        'text': msg['subject'],
        'lang': result['language'],
        'date': msg['date']
    }
    ans = _query_duckling(query)
    if ans['status'] == 900 or ans['status'] == 500:
        return TagStatus.server_error
    elif ans['status'] != 200:
        return TagStatus.client_error
    matches += _process_response(msg, ans, where='subject')
    result['annotations'] += matches
    return TagStatus.success
