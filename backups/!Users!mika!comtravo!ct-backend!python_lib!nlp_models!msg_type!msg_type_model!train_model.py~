from glob import glob
import os
import numpy as np
import json
from bokeh.plotting import figure, show
from email_tagger.brat import brat2ann
from sklearn.pipeline import Pipeline, FeatureUnion
from sklearn.cross_validation import StratifiedKFold
from sklearn.naive_bayes import MultinomialNB
from sklearn.grid_search import GridSearchCV
from sklearn.metrics import roc_curve, auc
from scipy import interp
import pickle
from bz2 import BZ2File
from msg_type_model.feature_extractors import RichFeatureExtractor, VectFeatureExtractor


def load_raw_data(path, load_from_file=False):
    print("Loading raw data...")
    if load_from_file:
        with open(os.path.join(path, 'raw_data.pkl'), 'rb') as f:
            raw_data = pickle.load(f)
            ids = pickle.load(f)
    else:
        raw_data = []
        ids = set()
        for file in glob(os.path.join(path, '**/*.ann'), recursive=True):
            file_stem = file.replace(".ann", "")
            ann, _ = brat2ann(file_stem)
            msg = json.load(open(file.replace(".ann", ".json"), 'r'))
            raw_data.append((os.path.basename(file_stem), msg, ann))
        ids.add(os.path.basename(file_stem))
        with open('raw_data.pkl', 'wb') as f:
            pickle.dump(raw_data, f)
            pickle.dump(ids, f)
    print("...got {} annotations for {} different message".format(len(raw_data), len(ids)))

    print("Getting labels and dropping unlabelled....")
    ids = set()
    raw_data = [(id, msg,
                 ann['tags'][0]['attributes']['request_type'],
                 ann['tags'][0]['attributes']['language'], ann) for (id, msg, ann) in raw_data
                if ann['tags'][0]['attributes']['request_type'] !=
                'booking|negotiation|rebooking|cancellation|other']
    print("...{} remained".format(len(raw_data)))

    print("Checking for agreeement...")
    data = {}
    for id, msg, lbl, lng, ann in raw_data:
        if id not in data:
            data[id] = {'msg': msg, 'lbl': lbl, 'lng': lng, 'ann': ann, 'ok': True, 'id': id}
        else:
            if data[id]['lbl'] != lbl:
                print('label mismatch for {}: {} vs. {}'.format(
                    id, data[id]['lbl'], lbl))
                data[id]['ok'] = False

    data = [x for x in data.values() if x['ok']]
    return data


def train_model(data, lang='de', plot=False):

    X = np.array([x for x in data if x['lng'] == lang])
    y = np.array([1 if x['lbl'] == 'booking' else -1 for x in data if x['lng'] == lang])

    n_outer_folds = 5
    n_inner_folds = 10
    outer_cv = StratifiedKFold(y, n_folds=n_outer_folds)
    mean_tpr = 0.0
    mean_fpr = np.linspace(0, 1, 100)
    params = {
        'union__vect__min_df': (1, 10),
        'union__vect__ngram_range': ((1, 1), (1, 2), (1, 3)),
        'clf__alpha': (0.1, 0.5, 1.0)}

    if plot:
        fig = figure(title='roc analysis', x_axis_label='fp', y_axis_label='tp')

    best_params = []
    for i, (tr_idx, te_idx) in enumerate(outer_cv):
        gnb_clf = Pipeline([
            ('union', FeatureUnion([
                ('rich', RichFeatureExtractor()),
                ('vect', VectFeatureExtractor(stem_lang='german' if lang == 'de' else 'english'))
            ])),
            ('clf', MultinomialNB())])
        inner_cv = StratifiedKFold(y[tr_idx], n_folds=n_inner_folds)
        cv = GridSearchCV(gnb_clf, params, cv=inner_cv, n_jobs=-1, verbose=1)
        res = cv.fit(X[tr_idx], y[tr_idx])
        proba = res.best_estimator_.predict_proba(X[te_idx])
        best_params.append(cv.best_params_)
        if plot:
            fpr, tpr, ths = roc_curve(y[te_idx], proba[:, 1])
            mean_tpr += interp(mean_fpr, fpr, tpr)
            mean_tpr[0] = 0.0
            roc_auc = auc(fpr, tpr)
            fig.line(fpr, tpr, line_width=1, legend='ROC fold %d (area = %0.2f)' % (i, roc_auc))

    if plot:
        mean_tpr /= n_outer_folds
        mean_roc_auc = auc(mean_fpr, mean_tpr)
        fig.line(mean_fpr, mean_tpr, line_width=3, line_color='red',
                 legend='ROC avg (area = %0.2f)' % (mean_roc_auc))
        show(fig)
    return cv.best_estimator_, best_params


def save_model(fname, *args):
    with BZ2File(fname, 'wb') as f:
        for a in args:
            pickle.dump(a, f)
