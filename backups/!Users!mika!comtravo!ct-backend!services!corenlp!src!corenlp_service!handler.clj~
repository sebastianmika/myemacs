(ns nlp-tools-server.handler
  (:require [compojure.core :refer [defroutes GET POST]]
            [compojure.handler :as handler]
            [compojure.route :as route]
            [ring.middleware.json :as ring-json]
            [duckling.core :as p]
            [clojure.data.json :as json]
            [clj-time.coerce :as t])
  (:import edu.stanford.nlp.pipeline.StanfordCoreNLP
           edu.stanford.nlp.pipeline.Annotation
           edu.stanford.nlp.pipeline.JSONOutputter
           edu.stanford.nlp.util.PropertiesUtils
           edu.stanford.nlp.util.StringUtils))


(defn re-pos [re s]
  "Given a regex re and string s, split s at all occurences of re,
   returning a list vector of maps with :start, :end and :text,
   where :text = (subs s :start :end) and :text will include the matched re"
        (loop [m (re-matcher re s)
               res []
               pos 0]
          (if (.find m)
            (recur m 
                   (conj res {:start pos :end (.end m) :text (subs s pos (.end m))})
                   (.end m))
            (if (< pos (count s)) 
              (conj res {:start pos :end (count s) :text (subs s pos)}) res)
            )))

;; English Stanford Core NLP annotation pipeline
(def pipeline_en
  (StanfordCoreNLP. (PropertiesUtils/fromString "annotators = tokenize, ssplit, pos, lemma, ner, parse"))
  )

;; German Stanford Core NLP annotation pipeline
;; see  http://stackoverflow.com/questions/37105266/stanford-parser-use-german-model-jar
(def pipeline_de
  (StanfordCoreNLP. (StringUtils/argsToProperties 
                     (into-array String ["-props", "StanfordCoreNLP-german.properties"])
                     )))

;; Wrapper for wit/duckling annotator (cf. https://github.com/wit-ai/duckling)
(defn duckling
  "Given a map with 'text' and 'lang', apply the wit/duckling parser
  for that lang to text. Currently supports 'de' and 'en'. Returns a
  list of results."
  [{:keys [text lang date] :or {lang "en"}}]
  {:pre [text lang date]}
  (p/parse (keyword (str lang "$core"))
                text
                [:time :duration :number]
                {:reference-time {:start (t/from-long (long date)) :grain :second}} 
                )
  )

(defn duckling-shift
  [lang date pos-split]
  (map (fn [p] (assoc p :start (+ (:start p) (:start pos-split)) :end (+ (:end p) (:start pos-split)))) (duckling {:text (:text pos-split) :lang lang :date date})))

(defn duckling-split
  [{:keys [text lang date] :or {lang "en"}}]
  {:pre [text lang date]}
  (apply concat (map (partial duckling-shift lang date) (re-pos #"\n" text)))
)

;; Wrapper for Stanford Core NLP
(defn nlp
  "Given a map with 'text' and 'lang', apply the Stanford Core NLP pipeline for that lang.
  Currently supports 'de' and 'en'. Returns a list with a map of the
  results per sentence - see edu.stanford.nlp.pipeline.JSONOutputter
  for details"
  [{:keys [text lang] :or {lang "en"}}]
  {:pre [text lang]}
  (def annotation (Annotation. text))
  (if (= lang "en")
    (.annotate pipeline_en annotation)
    (.annotate pipeline_de annotation)
    )
  (json/read-str (JSONOutputter/jsonPrint annotation))
  )

;; the actual routes
(defroutes app-routes
  (GET "/" [] "nlp tools server - post to /duckling or /corenlp")
  (POST "/duckling"
        {params :params}
        (if-not (and (contains? params :text) (contains? params :date) (contains? #{"de" "en" nil} (params :lang)))
          {:status 400 :body {:error "payload malformed (need 'text', 'date' and known 'lang' field)" :status 400}}
          {:status 200 :body {:result (duckling-split params) 
                              :status 200}}
          )
        )
  (POST "/corenlp"
        {params :params}
        (if-not (and (contains? params :text) (contains? #{"de" "en" nil} (params :lang)))
          {:status 400 :body {:error "payload malformed (need 'text' and known 'lang' field)" :status 400}}
          {:status 200 :body {:result (nlp params) 
                              :status 200}}
          )
        )
  (route/not-found {:status 404 :body {:error "not found" :status 404}})
  )

(defn wrap-exception-handling
  [handler]
  (fn [request]
    (try
      (handler request)
      (catch Exception e
        {:status 400 :body {:details (.getMessage e) :error "error in wit/duckling" :status 400}}
        )
      )
    )
  )

(defn init
  "Init function of module"
  []
  (p/load!)  ;; initialize wit/duckling framework
)

;; entry point for ring middleware
(def app
  (-> (handler/api app-routes)
      wrap-exception-handling
      (ring-json/wrap-json-response {:pretty true})
      (ring-json/wrap-json-params {:malformed-response 
                                   {:status 400 :headers {"Content-Type" "application/json"}
                                    :body (json/write-str {:status 400 :error "malformed json in body"})}})
      ))
