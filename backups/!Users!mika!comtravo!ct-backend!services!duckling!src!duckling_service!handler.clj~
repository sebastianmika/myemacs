(ns nlp-tools-server.handler
  (:require [compojure.core :refer [defroutes GET POST]]
            [compojure.handler :as handler]
            [compojure.route :as route]
            [ring.middleware.json :as ring-json]
            [duckling.core :as p]
            [clojure.data.json :as json]
            [clj-time.coerce :as t])
  )


(defn re-pos [re s]
  "Given a regex re and string s, split s at all occurences of re,
   returning a list vector of maps with :start, :end and :text,
   where :text = (subs s :start :end) and :text will include the matched re"
        (loop [m (re-matcher re s)
               res []
               pos 0]
          (if (.find m)
            (recur m 
                   (conj res {:start pos :end (.end m) :text (subs s pos (.end m))})
                   (.end m))
            (if (< pos (count s)) 
              (conj res {:start pos :end (count s) :text (subs s pos)}) res)
            )))

;; Wrapper for wit/duckling annotator (cf. https://github.com/wit-ai/duckling)
(defn duckling
  "Given a map with 'text' and 'lang', apply the wit/duckling parser
  for that lang to text. Currently supports 'de' and 'en'. Returns a
  list of results."
  [{:keys [text lang date] :or {lang "en"}}]
  {:pre [text lang date]}
  (p/parse (keyword (str lang "$core"))
                text
                [:time :duration :number]
                {:reference-time {:start (t/from-long (long date)) :grain :second}} 
                )
  )

(defn duckling-shift
  [lang date pos-split]
  (map (fn [p] (assoc p :start (+ (:start p) (:start pos-split)) :end (+ (:end p) (:start pos-split)))) (duckling {:text (:text pos-split) :lang lang :date date})))

(defn duckling-split
  [{:keys [text lang date] :or {lang "en"}}]
  {:pre [text lang date]}
  (apply concat (map (partial duckling-shift lang date) (re-pos #"\n" text)))
)

;; the actual routes
(defroutes app-routes
  (GET "/" [] "nlp tools server - post to /duckling or /corenlp")
  (POST "/duckling"
        {params :params}
        (if-not (and (contains? params :text) (contains? params :date) (contains? #{"de" "en" nil} (params :lang)))
          {:status 400 :body {:error "payload malformed (need 'text', 'date' and known 'lang' field)" :status 400}}
          {:status 200 :body {:result (duckling-split params) 
                              :status 200}}
          )
        )
  (route/not-found {:status 404 :body {:error "not found" :status 404}})
  )

(defn wrap-exception-handling
  [handler]
  (fn [request]
    (try
      (handler request)
      (catch Exception e
        {:status 400 :body {:details (.getMessage e) :error "error in wit/duckling" :status 400}}
        )
      )
    )
  )

(defn init
  "Init function of module"
  []
  (p/load!)  ;; initialize wit/duckling framework
)

;; entry point for ring middleware
(def app
  (-> (handler/api app-routes)
      wrap-exception-handling
      (ring-json/wrap-json-response {:pretty true})
      (ring-json/wrap-json-params {:malformed-response 
                                   {:status 400 :headers {"Content-Type" "application/json"}
                                    :body (json/write-str {:status 400 :error "malformed json in body"})}})
      ))
