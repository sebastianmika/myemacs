# A utility script to fetch mails from the comtravo buchungen@comtravo.com account

import httplib2
import os
import pickle
from datetime import datetime
from apiclient import discovery, errors
from apiclient.http import BatchHttpRequest
import oauth2client
from oauth2client import client, tools


# If modifying these scopes, delete your previously saved credentials
# at ~/.credentials/gmail-python-quickstart.json
SCOPES = 'https://www.googleapis.com/auth/gmail.readonly'
CLIENT_SECRET_FILE = 'client_secret_buchungen.json'
APPLICATION_NAME = 'Gmail API'


def get_credentials():
    """Gets valid user credentials from storage.

    If nothing has been stored, or if the stored credentials are invalid,
    the OAuth2 flow is completed to obtain the new credentials.

    Returns:
        Credentials, the obtained credential.
    """
    home_dir = os.path.expanduser('~')
    credential_dir = os.path.join(home_dir, '.credentials')
    if not os.path.exists(credential_dir):
        os.makedirs(credential_dir)
    credential_path = os.path.join(credential_dir,
                                   'gmail-python-mailFetcher.json')

    store = oauth2client.file.Storage(credential_path)
    credentials = store.get()
    if not credentials or credentials.invalid:
        flow = client.flow_from_clientsecrets(CLIENT_SECRET_FILE, SCOPES)
        flow.user_agent = APPLICATION_NAME
        credentials = tools.run(flow, store)
        print('Storing credentials to ' + credential_path)
    return credentials


def listMessagesMatchingQuery(service, user_id, query=''):
    """List all Messages of the user's mailbox matching the query.

    Args:
    service: Authorized Gmail API service instance.
    user_id: User's email address. The special value "me"
    can be used to indicate the authenticated user.
    query: String used to filter messages returned.
    Eg.- 'from:user@some_domain.com' for Messages from a particular sender.

    Returns:
    List of Messages that match the criteria of the query. Note that the
    returned list contains Message IDs, you must use get with the
    appropriate ID to get the details of a Message.
    """
    try:
        response = service.users().messages().list(userId=user_id,
                                                   q=query).execute()
        messages = []
        if 'messages' in response:
            messages.extend(response['messages'])

        while 'nextPageToken' in response:
            page_token = response['nextPageToken']
            response = service.users().messages().list(userId=user_id, q=query,
                                                       pageToken=page_token).execute()
            messages.extend(response['messages'])

        return messages
    except errors.HttpError as error:
        print('An error occurred: {}'.format(error))


messages = []


def addMsg(id, message, ex):
    '''Callback for batch fetching to get a message'''
    if ex is not None:
        print("Error: {}".format(ex))
        return
    # Decode raw message into python email object
    # msg_str = urlsafe_b64decode(message['raw'].encode('ASCII'))
    # mime_msg = message_from_bytes(msg_str)
    # Store raw response form Gmail only
    messages.append(message)


# Creates a Gmail API service object
credentials = get_credentials()
http = credentials.authorize(httplib2.Http())
service = discovery.build('gmail', 'v1', http=http)

message_ids = listMessagesMatchingQuery(service, "buchung@comtravo.com", query='')

print('# of messages {}:'.format(len(message_ids)))

messages = []
N = 20
for i in range(0, len(message_ids), N):
    print("{}Â of {}".format(i, len(message_ids)))
    batch = BatchHttpRequest()
    for msg_id in message_ids[i:i+N]:
        batch.add(service.users().messages().get(
            userId='buchung@comtravo.com', id=msg_id['id'], format='raw'),
                  callback=addMsg)
    batch.execute()

with open("raw_messages@{}.pkl".format(datetime.now().strftime('%Y-%m-%dT%H:%M:%S')), 'wb') as f:
    # need to dump one by one, otherwise we get an error (object too large - that is a bug in pickle)
    for msg in messages:
        pickle.dump(msg, f)
