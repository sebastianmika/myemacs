from io import StringIO
import pandas as pd
import numpy as np


city_cnt = 0
airport_cnt = 0
city_with_pop_10000 = 0
cities = StringIO()
airports = StringIO()
line_cnt = 0
with open('/Users/mika/Downloads/allCountries.txt', 'r', encoding='utf-8') as f:
    l = f.readline()
    while l:
        line_cnt += 1
        t = l.split('\t')
        if t[6] == 'P':
            city_cnt += 1
            if int(t[14]) > 10000:
                city_with_pop_10000 += 1
                cities.write(l)
        if t[7] == 'AIRP':
            airport_cnt += 1
            airports.write(l)
        if city_cnt % 1000 == 0:
            print("{}: cities: {} (>10000 pop: {}), airports: {}".format(line_cnt, city_cnt, city_with_pop_10000, airport_cnt))
        l = f.readline()

names = [
    'geonameid',  # integer id of record in geonames database
    'name',  # name of geographical point (utf8) varchar(200)
    'asciiname',  # name of geographical point in plain ascii
                  # characters, varchar(200)
    'alternatenames',  # alternatenames, comma separated, ascii names
                       # automatically transliterated, convenience
                       # attribute from alternatename table,
                       # varchar(10000)
    'latitude',  # latitude in decimal degrees (wgs84)
    'longitude',  # longitude in decimal degrees (wgs84)
    'feature class',  # see http://www.geonames.org/export/codes.html,
                      # char(1)
    'feature code',  # see http://www.geonames.org/export/codes.html,
                     # varchar(10)
    'country code',  # ISO-3166 2-letter country code, 2 characters
    'cc2',  # alternate country codes, comma separated, ISO-3166
            # 2-letter country code, 200 characters
    'admin1 code',  # fipscode (subject to change to iso code), see
                    # exceptions below, see file admin1Codes.txt for
                    # display names of this code; varchar(20)
    'admin2 code',  # code for the second administrative division, a
                    # county in the US, see file admin2Codes.txt;
                    # varchar(80)
    'admin3 code',  # code for third level administrative division,
                    # varchar(20)
    'admin4 code',  # code for fourth level administrative division,
                    # varchar(20)
    'population',  # bigint (8 byte int)
    'elevation',  # in meters, integer
    'dem',  # digital elevation model, srtm3 or gtopo30, average
            # elevation of 3''x3'' (ca 90mx90m) or 30''x30'' (ca
            # 900mx900m) area in meters, integer. srtm processed by
            # cgiar/ciat.
    'timezone',  # the timezone id (see file timeZone.txt) varchar(40)
    'modification date'   # date of last modification in yyyy-MM-dd format
]

cities.seek(0)
cities = pd.read_csv(cities, sep='\t', header=None, names=names, dtype={'geonameid': np.int32})
cities['population_rank'] = cities['population']/cities['population'].max()
cities = cities[['geonameid', 'name', 'latitude', 'longitude', 'country code', 'population_rank', 'timezone']]
cities.columns = ['geonameid', 'name', 'latitude', 'longitude', 'country_code', 'population_rank', 'timezone']
cities = cities.set_index('geonameid')

airports.seek(0)
airports = pd.read_csv(airports, sep='\t', header=None, names=names)
airports = airports[['geonameid', 'name', 'latitude', 'longitude', 'country code', 'timezone']]
airports.columns = ['geonameid', 'name', 'latitude', 'longitude', 'country_code', 'timezone']
airports = airports.set_index('geonameid')

names = [
    'alternateNameId',  # the id of this alternate name, int
    'geonameid',  # geonameId referring to id in table 'geoname', int
    'isolanguage',  # iso 639 language code 2- or 3-characters; 4-characters 'post' for postal codes and 'iata','icao' and faac for airport codes, fr_1793 for French Revolution names,  abbr for abbreviation, link for a website, varchar(7)
    'alternate name',  # alternate name or name variant, varchar(400)
    'isPreferredName',  # '1', if this alternate name is an official/preferred name
    'isShortName',  # '1', if this is a short name like 'California' for 'State of California'
    'isColloquial',  # '1', if this alternate name is a colloquial or slang term
    'isHistoric',  # '1', if this alternate name is historic and was used in the past
]

an = pd.read_csv('/Users/mika/Downloads/alternateNames.txt', sep='\t', header=None, names=names,
                 dtype={'alternateNameId': np.int32,
                        'geonameid': np.int32})
an.isPreferredName = an.isPreferredName == 1.0
an.isShortName = an.isShortName == 1.0
an.isColloquial = an.isColloquial == 1.0
an.isHistoric = an.isHistoric == 1.0
an.columns = ['alternateNameId',  'geonameid',  'isolanguage', 'name', 'is_preferred', 'is_short_name', 'is_colloquial', 'is_historic']
# take only en and de alternatives
an = an[(an.isolanguage == 'de') | (an.isolanguage == 'en')]
# Get rid of historic names
an = an[-an.is_historic]
# Drop cols we do not need
an = an[['geonameid', 'isolanguage', 'name']]
# Convert alternative names to list of json objects
ang = an.groupby('geonameid').apply(lambda x: [y.drop('geonameid').to_dict() for _, y in x.iterrows()])
ang.name = 'alternate_names'

cities = cities.join(ang)
cities.to_json('org.geonames.cities.json', orient='index')

airports = airports.join(ang)
airports.to_json('org.geonames.airports.json', orient='index')

