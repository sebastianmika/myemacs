import bz2
import json
import requests


def get_data():
    return json.loads(
        bz2.BZ2File('annotated_corpus_2016-12-12T11:18:51Z.json.bz2', 'rb').read().decode())


def get_duckling(txt, lang):
    duckling_uri = 'http://localhost:8888/duckling'
    query = {
        'text': txt,
        'lang': lang,
        'date': 1451606400000  # 01.01.2016 00:00:00
    }
    try:
        r = requests.post(
            duckling_uri,
            headers={'Accept': 'application/json', 'Content-Type': 'application/json'},
            data=json.dumps(query),
            verify=False)  # Self signed cert...
    except requests.exceptions.ConnectionError as e:
        return None
    if r.status_code == 200:
        return r.json()


def ss(s):
    return s.replace('\n', ' ').replace('\t', ' ').replace('\r', ' ').replace('\b', ' ')


def doit(data, fname):
    targs = ['Time']
    for lang in ['de', 'en']:
        for targ in targs:
            f = open('{}_{}_{}.csv'.format(fname, targ, lang), 'w')
            for d in data:
                if d['ann']['language'] != lang:
                    continue
                anns = d['ann']['annotations']
                i = 0
                while i < len(anns):
                    if targ not in anns[i]['rner']:
                        i += 1
                        continue
                    else:
                        matches = [anns[i]]
                        where = anns[i]['where']
                        assert anns[i]['rner'].startswith('B-')
                        while True:
                            i += 1
                            if (i == len(anns) or not anns[i]['rner'].startswith('I-') or
                               anns[i]['where'] != where):
                                break
                            assert targ in anns[i]['rner']
                            matches.append(anns[i])
                        # emit
                        mstr = ''.join(([m['text'] + m['after'] for m in matches[:-1]] +
                                        [matches[-1]['text']]))
                        djson = get_duckling(mstr, lang)
                        dstr = ""
                        if djson:
                            dres = [d for d in djson['result'] if d['dim'] == 'time']
                            if len(dres) > 0 and dres[0]['dim'] == 'time':
                                if dres[0]['value']['type'] == 'value':
                                    dstr = "{:^40s} $$ {:24.24s} $$".format(
                                        ss(dres[0]['body']),
                                        str(dres[0]['value']['value']))
                                elif dres[0]['value']['type'] == 'interval':
                                    from_str = ''
                                    to_str = ''
                                    if 'from' in dres[0]['value']:
                                        from_str = str(dres[0]['value']['from']['value'])
                                    if 'to' in dres[0]['value']:
                                        to_str = str(dres[0]['value']['to']['value'])
                                    dstr = "{:^40s} $$ {:24.24s} $$ {:24.24s}".format(
                                        ss(dres[0]['body']), from_str, to_str)
                        bstr = d['msg'][where][
                            matches[0]['start']-20:matches[0]['start']]
                        ee = matches[-1]['start'] + matches[-1]['length']
                        astr = d['msg'][where][ee:ee+20]
                        f.write('{:10.10s} $$ {:22.22s} $$ {:<10.10s} $$ {:>20.20s} $$ {:^40s} '
                                '$$ {:<20.20s} $$ {}\n'.format(
                                    "ok",
                                    d['id'], matches[0]['rner'][2:],
                                    ss(bstr), ss(mstr), ss(astr), ss(dstr)))
    f.close()
