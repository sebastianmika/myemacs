from concurrent.futures import ThreadPoolExecutor, wait
import logging
from . base_tagger import TagStatus, BaseTagger
from . language_tagger import LanguageTagger
from . type_tagger import TypeTagger
from . source_tagger import SourceTagger
from . greeting_tagger import GreetingTagger
from . eom_tagger import EOMTagger
from . reply_tagger import ReplyTagger
from . truncate_tagger import TruncateTagger
from . spacy_tagger import SpacyTagger
from . crm_company_tagger import CRMCompanyTagger
from . crm_person_tagger import CRMPersonTagger
from . person_tagger import PersonTagger
from . prob_tagger import ProbTagger
from . iata_tagger import IATATagger
from . fn_tagger import FlightNumberTagger
from . time_tagger import TimeTagger
from . geonames_tagger import GeoNamesTagger
from . isbooking_tagger import IsBookingTagger
from . content_tagger import ContentTagger
from . event_tagger import EventTagger
from . merge_annotations import MergeAnnotationsTagger
from . airline_tagger import AirlineTagger
from . categoryorclass_tagger import CategoryOrClassTagger
from . luggage_tagger import LuggageTagger

logger = logging.getLogger(__name__)


class MailTagger(BaseTagger):
    def __init__(self, only_main_body=True):
        super(MailTagger, self).__init__()
        self.only_main_body = only_main_body
        self.language_tagger = LanguageTagger()
        self.source_tagger = SourceTagger()
        self.type_tagger = TypeTagger()
        self.greeting_tagger = GreetingTagger()
        self.eom_tagger = EOMTagger()
        self.reply_tagger = ReplyTagger()
        self.crm_company_tagger = CRMCompanyTagger()
        self.crm_person_tagger = CRMPersonTagger()
        self.person_tagger = PersonTagger()
        self.prob_tagger = ProbTagger()
        self.iata_tagger = IATATagger()
        self.fn_tagger = FlightNumberTagger()
        self.time_tagger = TimeTagger()
        self.geonames_tagger = GeoNamesTagger()
        self.isbooking_tagger = IsBookingTagger()
        self.content_tagger = ContentTagger()
        self.event_tagger = EventTagger()
        self.merge_tagger = MergeAnnotationsTagger()
        self.truncate_tagger = TruncateTagger(only_main_body)
        self.spacy_tagger = SpacyTagger()
        self.airline_tagger = AirlineTagger()
        self.category_or_class_tagger = CategoryOrClassTagger()
        self.luggage_tagger = LuggageTagger()
        # We never have more than 3 active futures + the main thread
        self.executor = ThreadPoolExecutor(max_workers=4)

    def tag(self, msg, result):
        # General message attributes
        self.type_tagger(msg, result)
        self.source_tagger(msg, result)

        # Get all annotations in turn.
        # We start with nothing and will see what we get :-)
        result['annotations'] = []

        # Greeting part
        self.greeting_tagger(msg, result)
        # End of message part (i.e. anything and including the signoff phrase)
        self.eom_tagger(msg, result)
        # Replies in the message
        self.reply_tagger(msg, result)

        # Tag language
        if self.language_tagger(msg, result) != TagStatus.success:
            # --> in this case we return no annotations at all
            result.pop('annotations')
            return TagStatus.success
        if result['language'] not in ['de', 'en']:
            logger.info('language detected {} which is not supported'.format(result['language']))
            # --> in this case we return no annotations at all
            result.pop('annotations')
            return TagStatus.success

        # Shrink message for further processing if only the main part
        # between Greeting and EndOfMsg/Reply should be tagged
        #
        # -> needs greeting, reply and eom, modifies msg!!!
        self.truncate_tagger(msg, result)

        # Use futures for these calls:
        #
        # * spacy runs largely in C/Cython
        # * company tagger queries ES
        # * person tagger queries ES
        # * time tagger queries duckling
        #
        # In the other taggers using futures should/would not make a
        # lot of sense as they are all pure python code and hence will
        # not execute in parallel because of the GIL

        # Get spacy annotations
        spacy_future = self.executor.submit(self.spacy_tagger, msg, result)
        # get companies and users from crm based on emails in msg
        crm_company_future = self.executor.submit(self.crm_company_tagger, msg, result)
        # time expressions / duckling
        time_future = self.executor.submit(self.time_tagger, msg, result)

        # iata codes
        self.iata_tagger(msg, result)
        # flight numbers
        self.fn_tagger(msg, result)
        # cities (15.000 largest geonames)
        self.geonames_tagger(msg, result)
        # airline or alliance
        self.airline_tagger(msg, result)
        # category of class
        self.category_or_class_tagger(msg, result)
        # luggage
        self.luggage_tagger(msg, result)

        # Need company tagger to be finished before we call person tagger
        crm_company_future.result(10)
        crm_person_future = self.executor.submit(self.crm_person_tagger, msg, result)
        if wait([spacy_future, time_future, crm_person_future], timeout=10).not_done:
            raise Exception("could not sync all futures within timeout")
        # Find persons from CRM in message
        self.person_tagger(msg, result)  # depends on crm_person_tagger to be successful
        # Update company probs
        prob_future = self.executor.submit(self.prob_tagger, msg, result)
        # remove overlapping annotations for the same part of text
        if self.merge_tagger(msg, result) != TagStatus.success:
            # clean up
            result.pop('spacy')
            result['annotations'] = []

        # Get prob. that this is a booking
        self.isbooking_tagger(msg, result)
        # Get prob. that various request items are mentioned
        self.content_tagger(msg, result)
        # Get Events
        self.event_tagger(msg, result)

        if not result['annotations']:
            result.pop('annotations')

        # Wait for final future
        prob_future.result(5)

        return TagStatus.success
