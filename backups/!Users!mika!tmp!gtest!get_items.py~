import os
import json
import requests
from cachetools.func import ttl_cache
from items_to_ts import items_to_ts

# Silence non valid cert warning
requests.packages.urllib3.disable_warnings(
    requests.packages.urllib3.exceptions.InsecureRequestWarning)

columns = ["booking_item.status", "booking_item.id",
           "booking_item.rebooked_from", "booking_item.refund_for",
           "booking_item.canceled", "booking_item.rebooked",
           "booking_item.status", "booking_item.type",
           "booking_item.meta_data.created_at", "company.name",
           "booking_item.canceled_at", "booking_item.client_accounting_item.amount",
           "booking_item.client_accounting_item.vat",
           "booking_item.client_accounting_item.tax_class",
           "client_accounting.invoice_id", "traveler.full_name",
           "booking_item.client_accounting_item.client_cost_center_1",
           "booking_item.client_accounting_item.client_cost_center_2",
           "parent_status"]


@ttl_cache(maxsize=32, ttl=60)
def get_booking_items(start_date, end_date, freq):
    """Get all relevant booking items from elasticsearch"""
    bi_uri = os.environ.get('COMTRAVO_BI_URI', 'http://bi')
    bi_user = os.environ.get('COMTRAVO_BI_USER')
    bi_password = os.environ.get('COMTRAVO_BI_PASSWORD')
    booking_items = []
    print("CALLED THE FUNC >>>>>>>>>>>>>>>>>")
    try:
        # Get scroll id, filter to include start_date and exclude end_date UTC 00:00:00
        query = {
            "query": {
                "bool": {
                    "should": [
                        {
                            "range": {
                                "booking_item.meta_data.created_at": {
                                    "gte": '{}'.format(start_date.strftime("%Y-%m-%dT%H:%M:%SZ")),
                                    "lt": '{}'.format(end_date.strftime("%Y-%m-%dT%H:%M:%SZ"))
                                }
                            }
                        },
                        {
                            "range": {
                                "booking_item.canceled_at": {
                                    "gte": '{}'.format(start_date.strftime("%Y-%m-%dT%H:%M:%SZ")),
                                    "lt": '{}'.format(end_date.strftime("%Y-%m-%dT%H:%M:%SZ"))
                                }
                            }
                        }
                    ],
                    "minimum_should_match": 1
                }
            },
            "_source": {
                "include": columns}
        }
        r = requests.post(bi_uri + '/booking_items/_search?scroll=1m&size=1000',
                          headers={'Accept': 'application/json',
                                   'Content-Type': 'application/json'},
                          auth=(bi_user, bi_password),
                          data=json.dumps(query),
                          verify=False)  # Self signed cert...
        if r.status_code != 200:
            raise Exception('querying elasticsearch on {} failed: {}\n{}'.format(
                bi_uri,
                r.status_code,
                query))
        # Get results
        r = r.json()
        scroll_id = r['_scroll_id']
        booking_items += r['hits']['hits']
        while True:
            # Iterate scroll until no more items are left
            r = requests.get(bi_uri + '/_search/scroll',
                             headers={'Accept': 'application/json',
                                      'Content-Type': 'application/json'},
                             data=json.dumps({'scroll': '1m',
                                              'scroll_id': scroll_id}),
                             auth=(bi_user, bi_password),
                             verify=False)  # Self signed cert...
            if r.status_code != 200:
                raise Exception('querying elasticsearch on {} failed: {}'.format(
                    bi_uri,
                    r.status_code))
            r = r.json()
            scroll_id = r['_scroll_id']
            if len(r['hits']['hits']) == 0:
                break
            booking_items += r['hits']['hits']
    except requests.exceptions.ConnectionError as e:
        raise Exception("could not connect to elasticsearch: {}".format(e))
    # Convert to timeseries
    report, items = items_to_ts(booking_items, start_date, end_date, freq, columns)
    return booking_items, report, items
